{"name":"Database class","body":"# Database class\r\n\r\nWelcome! To help clear up some of the confusion newcomers have when starting to use the Database class, I decided to provide this documentation. [Skip straight to the reference material](#reference).\r\n\r\n**Please note:** all examples in this documentation are using the Enyo database class (because that is far and away the most popular). All other info should applie to the other versions, as well. You just might need to write slightly different code for constructing the Database object, for instance.\r\n\r\n## Introduction\r\n\r\nThe Database class is simply a wrapper around the native WebSQL API. When I first started working with WebSQL for [TapNote](http://onecrayon.com/tapnote/), I found the API to be entirely too complicated for my tastes. At the time I was working quite heavily in Prototype (which was part of the Mojo framework on the original webOS smartphones), so the class uses a number of Prototype-like methods. Here are some basic things you should know:\r\n\r\n**Almost everything is asynchronous.** A common mistake beginning users make is to do something like call the `query()` method to insert data, and then immediately try to work with the database again. This will not work, because all calls to the database are asynchronous. Instead, you will always need to pass a function to the `onSuccess` option, and then do any follow-up parsing there.\r\n\r\n**Why you should use it:** this class abstracts away from the WebSQL boilerplate, making your own code slightly less complex and a lot nicer to read. Most people will end up writing a generic query method when they work with WebSQL anyway; Database just does it for you. It also provides helper methods for generating things like simple SELECT/INSERT/UPDATE queries. Additionally, populating your database initially is much easier because the class provides methods for doing so via JSON (no need to write a bunch of INSERTS). Lastly, the class is particularly applicable to use on webOS because it will run on everything from Mojo 1.4 up to Enyo 2. And if for whatever reason you want to use it on a non-webOS based project, there's a version that should work on its own in any environment that supports Javascript and the WebSQL API.\r\n\r\n**Why you should avoid it:** the Database class makes total sense to me, because I wrote it. You, however, are going to have learn a new (albeit simple) API. If you are not familiar with the WebSQL methods, what is going on behind the scenes may seem like Black Magic, which could make debugging your code difficult if anything goes wrong.\r\n\r\n**WebSQL has serious downsides.** Most environments limit WebSQL databases to 5 MB, so simply because it is SQL does not mean you can store vast amounts of data. Additionally, every implementation that I know of uses SQLite as its database engine, which has its own set of quirks. If you are doing anything remotely more complicated than simple SELECTS, be aware that you will likely need to visit the SQLite documentation if something weird starts happening. You should probably do so anyway, because SQLite does some special magic when it comes to tracking auto-incrementing row IDs and so forth that is not normal for most SQL implementations you are probably used to.\r\n\r\n## Basic usage\r\n\r\nThere are two steps you need to take before you can start running queries:\r\n\r\n1. You must include the database-enyo.js file using `enyo.depends`\r\n2. You must initialize your database\r\n\r\nYou can only have a single connection to your database open; I typically make it a component of my root app Kind or model, and then route all database activity through that.\r\n\r\nTo include the database Kind in your project, add it to your root `depends.js` file:\r\n\r\n```javascript\r\nenyo.depends(\r\n    \"source/database-enyo.js\",\r\n    // Include other app Kinds here\r\n);\r\n```\r\n\r\nTo initialize it, add it as a component in your Kind and initialize it. Here is how I do so in the TapNote model Kind:\r\n\r\n```javascript\r\nenyo.kind({\r\n    name: 'TapNote.DocumentsModel',\r\n    kind: enyo.Component,\r\n    components: [\r\n        {\r\n            name: \"db\",\r\n            kind: \"onecrayon.Database\",\r\n            database: 'ext:com.onecrayon.tapnote'),\r\n            version: \"\",\r\n            debug: (enyo.exists(enyo.fetchFrameworkConfig().debuggingEnabled) ? enyo.fetchFrameworkConfig().debuggingEnabled : false)\r\n        }\r\n    ],\r\n    \r\n    constructor: function() {\r\n        this.inherited(arguments);\r\n        \r\n        // Ensures we don't try to load items multiple times while in asynchronous communication w/ database\r\n        // Is also set to true while loading table schema and intro data\r\n        this.runningQuery = false;\r\n        \r\n        // This is a common pattern for me; I do all my multi-use bindings in the constructor\r\n        this.bound = {\r\n            finishFirstRun: enyo.bind(this, this.finishFirstRun)\r\n        };\r\n    },\r\n    \r\n    create: function() {\r\n        // Components are not available until after this.inherited in create\r\n        this.inherited(arguments);\r\n        \r\n        if (!localStorage[\"TapNote.firstRun\"] && !this.runningQuery) {\r\n            this.populateDatabase();\r\n        }\r\n    },\r\n    \r\n    // These methods are custom ones of my own, not standard Enyo overrides\r\n    \r\n    populateDatabase: function() {\r\n        this.runningQuery = true;\r\n        // Run the table creation schema and populate our items list\r\n        this.$.db.setSchemaFromURL('path/to/schema.json', {\r\n            onSuccess: this.bound.finishFirstRun\r\n        });\r\n    },\r\n    \r\n    // This finishes the first run insert and calls the insert method\r\n    finishFirstRun: function() {\r\n        localStorage[\"TapNote.firstRun\"] = \"true\";\r\n        // Set the database version (allows for schema upgrades down the road)\r\n        this.$.db.changeVersion('1.0');\r\n        this.runningQuery = false;\r\n        // I proceed to refresh my document listings here\r\n    },\r\n    \r\n    // Lots of other methods follow, but you get the idea\r\n});\r\n```\r\n\r\nNote that you don't need to copy and paste that code. All you have to make sure you do is add your database as a component, then load in a table schema before you start trying to use it. If you are not inserting data when you first create the database, you can load a table schema every time (because it will automatically use `CREATE TABLE IF NOT EXISTS`). However, this can slow down your launch times, so using cookies, localStorage, or some other method to track if the database has been populated is generally a good idea.\r\n\r\nThe schema.json file for TapNote looks something like this:\r\n\r\n```json\r\n[\r\n    {\r\n        \"table\": \"documents\",\r\n        \"columns\": [\r\n            { \"column\": \"rowID\", \"type\": \"INTEGER\", \"constraints\": [\"PRIMARY KEY\"] },\r\n            { \"column\": \"title\", \"type\": \"TEXT\" },\r\n            { \"column\": \"content\", \"type\": \"TEXT\" },\r\n            { \"column\": \"description\", \"type\": \"TEXT\" }\r\n        ],\r\n        \"data\": [\r\n            {\r\n                \"title\": \"Welcome to TapNote\",\r\n                \"description\": \"Tap this document to view it, or swipe to delete.\",\r\n                \"content\": \"Using TapNote should be familiar if you have used other WebOS apps, but here are a few tips:\\n\\n[...]\"\r\n            }\r\n        ]\r\n    }\r\n]\r\n```\r\n\r\nThe `data` key is optional, and if present it will be used to insert data after you create the table. You could optionally place your initial inserts in their own JSON file and run it in your `onSuccess` function after the schema creation.\r\n\r\nAfter the database component is added and the table schema initialized, the database class is ready to be used! For instance, if I wanted to fetch a listing of all my documents in TapNote, I might do this in the model class:\r\n\r\n```javascript\r\nlistAllDocuments: function(callback) {\r\n    var sql = 'SELECT title, description FROM documents';\r\n    this.$.db.query(sql, { \"onSuccess\": callback });\r\n}\r\n```\r\n\r\nWhatever I pass as the callback to my model will receive an array of objects, each of which will have a `title` and `description` property. As you would expect, if nothing matches the query, callback will receive an empty array.\r\n\r\nIf you want to select based on potentially unsafe input, use an object instead of a string for your query:\r\n\r\n```javascript\r\nsearchTitles: function(searchString, callback) {\r\n    // Sanitize the search string for backslash escapes and wildcards\r\n    searchString = searchString.replace(/\\\\/g, '\\\\\\\\').replace(/(%|_)/g, '\\\\$1');\r\n    // Add wildcards around the searchString\r\n    searchString = '%' + searchString + '%';\r\n    // Construct our query object\r\n    var query = {\r\n        \"sql\": \"SELECT title, description FROM documents WHERE title LIKE ? ESCAPE '\\\\'\",\r\n        \"values\": [ searchString ]\r\n    };\r\n    // Run the query\r\n    this.$.db.query(query, { \"onSuccess\": callback });\r\n}\r\n```\r\n\r\nThis pattern uses a feature native to SQLite. For every `?` character in the SQL, SQLite will automatically insert the values from the `values` array in order after sanitizing them against SQL attacks. For both the `query()` and `queries()` methods, you can pass either an object with an `sql` and `values` property, or a string.\r\n\r\nYou should at this point have a pretty good grasp on the basics of using the Database class, so go forth and make awesome software! You can find a full reference for its properties and methods below.\r\n\r\n## JSON Formatting\r\n\r\nSeveral Database methods accept JSON (either in files or as a string), since a core goal of the Database class is to enable you to easily port data into your database using JSON.\r\n\r\nAll JSON uses the same naming scheme. Your root object should be an array, although if you only have one object you want to work with you can make it your root instead.\r\n\r\nInstead of objects defining a table, you can also pass in arbitrary strings of SQL. This is primarily useful if you are upgrading your schema and need to ALTER TABLE or similar.\r\n\r\n```json\r\n[\r\n    {\r\n        \"table\": \"(string, required) name of this table\",\r\n        \"columns\": [\r\n            {\r\n                \"column\": \"(string, required) name of the column\",\r\n                \"type\": \"(string, required) column type\",\r\n                \"constraints\": [\r\n                    \"array of optional string restraints\"\r\n                ]\r\n            },\r\n            {\r\n                \"column\": \"anotherColumn\",\r\n                \"type\": \"TEXT\"\r\n            }\r\n        ],\r\n        \"data\": [\r\n            { \"anotherColumn\": \"keys are column names; values column contents\" },\r\n            { \"anotherColumn\": \"more example data\" }\r\n        ]\r\n    },\r\n    {\r\n        \"table\": \"secondTable\",\r\n        \"columns\": [\r\n            {\r\n                \"column\": \"helloWorld\",\r\n                \"type\": \"TEXT\"\r\n            }\r\n        ]\r\n    },\r\n    \"ALTER TABLE table1 ADD COLUMN category TEXT\"\r\n]\r\n```\r\n\r\nBoth `columns` and `data` are optional; you can use this scheme to define tables, populate them with data, or both (depending on the method you are calling).\r\n\r\n<h2 id='reference'>Reference</h2>\r\n\r\nThere are no public properties on the database object; everything you need to access is available via a method.\r\n\r\n### Query objects\r\n\r\nQuery objects are generic objects that have the following properties:\r\n\r\n* **sql** (string): the SQL you want to execute\r\n* **values** (array): values for `?` placeholders in the SQL\r\n\r\n**Usage:**\r\n\r\n```javascript\r\nvar query = {\r\n    \"sql\": \"SELECT * FROM table WHERE rowID = ?\",\r\n    \"values\": [ 1 ]\r\n};\r\n```\r\n\r\n### Constructor\r\n\r\nConstruct a single, shared Database object by assigning it to your components in your model or root application Kind. It accepts four keyword options:\r\n\r\n* **database** (string, required): the name of your database\r\n* **version** (string, optional): the version of your database. Typically a numeric string like `\"1\"` or `\"1.0\"`, but there are no actual rules for what you should put here\r\n* **estimatedSize** (int, optional): the estimated size in bytes of your database\r\n* **debug** (bool, optional): if `true` the database will log every query it runs for help with debugging\r\n\r\n**Usage:**\r\n\r\n```javascript\r\ncomponents: [\r\n    {\r\n        name: \"db\",\r\n        kind: \"onecrayon.Database\",\r\n        database: 'ext:MyDatabase',\r\n        version: \"\",\r\n        debug: false\r\n    }\r\n]\r\n```\r\n\r\n### getVersion()\r\n\r\n_Returns string_; the version of the database.\r\n\r\n### lastInsertId()\r\n\r\n_Returns int_; the last ID inserted. This only works if you have just completed a single INSERT statement.\r\n\r\n### close()\r\n\r\n_Returns nothing_; closes the database connection. Why you'd want to do this, I don't know. Included for completeness' sake.\r\n\r\n### query(sql, options)\r\n\r\n_Returns nothing_; execute an arbitrary SQL command on the database.\r\n\r\n**Parameters:**\r\n\r\n* **sql** (string or query object, required): the query to execute\r\n* **options** (object, optional):\r\n    * **values** (array, optional): replacements for '?' placeholders in SQL (only use if not passing a query object)\r\n    * **onSuccess** (function, recommended): function to call on successful query. The function receives a single argument, which is an array of objects.\r\n    * **onError** (function, optional): method to call on error; defaults to logging\r\n\r\n### queries(queries, options)\r\n\r\n_Returns nothing_; execute multiple arbitrary SQL queries on the database as a single transaction (group of inserts, for instance). This is *not appropriate for SELECT* (or anything that returns rows). The last inserted ID will *not* be set when using this method. The `onSuccess` and `onError` functions will only be called for the transaction as a whole, not individual queries.\r\n\r\n**Parameters:**\r\n\r\n* **queries** (array of strings or query objects, required): the SQL queries you want to execute\r\n* **options** (object, optional):\r\n    * `onSuccess`: function to execute on final query success\r\n    * `onError`: function to execute on transaction error\r\n\r\n### setSchema(schema, options)\r\n\r\n_Returns nothing_; defines/inserts a table layout (if it doesn't already exist) and inserts any data that you've provided.\r\n\r\n**Parameters:**\r\n\r\n* **schema** (array or object, required): conforms to the JSON scheme outlined above, and defines one or more tables to create in your database. **Does not accept JSON strings!** To setup your schema using JSON instead of native Javascript objects, use `setSchemaFromUrl()`.\r\n* **options** (object, optional):\r\n    * **onSuccess** (function): called after successful transactions\r\n    * **onError** (function): called on error for transactions\r\n\r\nPLEASE NOTE: the onSuccess and onError functions may be called multiple times if you are inserting data as well as defining a table schema.\r\n\r\n### setSchemaFromUrl(url, options)\r\n\r\n_Returns nothing_; allows you to set your schema using an arbitrary JSON file.\r\n\r\n**Parameters:**\r\n\r\n* **url** (string, required): local or remote URL for JSON file\r\n* **options** (object): same as setSchema options (above)\r\n\r\n### insertData(data, options)\r\n\r\n_Returns nothing_; inserts arbitrary data using Javascript objects.\r\n\r\n**Parameters**\r\n\r\n* **data** (array or object, required): the formatting is the same as for the schema, just without the `columns` property.\r\n* **options** (object):\r\n    * **onSuccess** (function): success callback\r\n    * **onError** (function): error callback\r\n\r\n### insertDataFromUrl(url, options)\r\n\r\n_Returns nothing_; allows you to populate data using arbitrary JSON file.\r\n\r\n**Parameters:**\r\n\r\n* **url** (string, required): local or remote URL for JSON file\r\n* **options** (object): same as insertData options (above)\r\n\r\n### changeVersion(newVersion)\r\n\r\n_Returns nothing_; change the version of the database.\r\n\r\n**WARNING:** you must have NO other database connections active when you do this.\r\n\r\n### changeVersionWithSchema(newVersion, schema, options)\r\n\r\n_Returns nothing_; change the version of the database and apply any schema updates specified in the `schema` object. **NOTE:** You cannot insert data with this call. Instead, run your schema update and then use `insertData()` in your success callback.\r\n\r\n**Parameters:**\r\n\r\n* **newVersion** (string or int, required)\r\n* **schema** (array or object): same as setSchema (documented above), minus any data insertion support\r\n* **options** (object): same as setSchema options\r\n\r\n### changeVersionWithSchemaFromUrl(newVersion, url, options)\r\n\r\n_Returns nothing_; change the version of the database and apply any schema updates specified in the schema JSON file located at `url`.\r\n\r\nParameters are otherwise identical to `changeVerisonWithSchema()`.\r\n\r\n### getInsert(tableName, data)\r\n\r\n_Returns query object_; helper method to generate SQL for inserting data into a particular table.\r\n\r\n**Parameters:**\r\n\r\n* **tableName** (string, required)\r\n* **data** (object, required): keys are column names (same format as data objects in schema)\r\n\r\n### getSelect(tableName, columns, where)\r\n\r\n_Returns query object_; helper method for generating very simple SQL for selecting data.\r\n\r\n**Parameters:**\r\n\r\n* **tableName** (string, required)\r\n* **columns** (string, array, or null): names of the columns to return; if `null` will return all columns\r\n* **where** (object): every key/value pair will create a WHERE clause, joined with AND. So for instance, `{ \"title\": \"Hello\", \"content\": \"World\" }` will result in `WHERE title = 'Hello' AND content = 'World'`\r\n\r\n### getUpdate(tableName, data, where)\r\n\r\n_Returns query object_; helper method for generating simple SQL for updating a table record.\r\n\r\n**Parameters:**\r\n\r\n* **tableName** (string, required)\r\n* **data** (object, required): keys are column names (same format as data objects in schema)\r\n* **where** (object, optional): same formatting as `getSelect()` above\r\n\r\n### getDelete(tableName, where)\r\n\r\n_Returns query object_; helper method for generating simple SQL for deleting a table record.\r\n\r\n**Parameters:**\r\n\r\n* **tableName** (string, required)\r\n* **where** (object, required): same formatting as `getSelect()` above\r\n\r\n### getCreateTable(tableName, columns, ifNotExists)\r\n\r\n_Returns string_; helper method to generate simple SQL for creating a table. Returns a string because table creation does not support value substitution. **Note:** this method is vulnerable to SQL injections! _Do not_ use user-supplied values!\r\n\r\n**Parameters:**\r\n\r\n* **tableName** (string, required)\r\n* **columns** (array, required): uses syntax from setSchema (see above)\r\n* **ifNotExists** (bool, defaults to true): if `true`, then the table will only be created if it does not already exist\r\n\r\n### getDropTable(tableName)\r\n\r\n_Returns string_; helper method to generate SQL for dropping a table. **Note:** this method is vulnerable to SQL injections! _Do not_ use user-supplied values for the tableName!\r\n","tagline":"A Javascript class to ease working with HTML5 SQLite databases in webOS, the Enyo framework, and beyond","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}